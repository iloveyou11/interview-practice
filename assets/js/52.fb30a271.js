(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{408:function(t,e,a){"use strict";a.r(e);var s=a(44),c=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"react中setstate同步还是异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react中setstate同步还是异步"}},[t._v("#")]),t._v(" React中setState同步还是异步？")]),t._v(" "),a("p",[t._v("在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state 。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。")]),t._v(" "),a("p",[a("strong",[t._v("原因：")])]),t._v(" "),a("p",[t._v("在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。")]),t._v(" "),a("p",[a("strong",[t._v("注意：")])]),t._v(" "),a("p",[t._v("这里所说的同步异步， 并不是真正的同步异步， 它还是同步执行的。这里的异步指的是多个state会合成到一起进行批量更新。")]),t._v(" "),a("p",[t._v("setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。")])])}),[],!1,null,null,null);e.default=c.exports}}]);