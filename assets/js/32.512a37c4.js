(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{388:function(e,t,v){"use strict";v.r(t);var _=v(44),l=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h3",{attrs:{id:"浏览器和-node-事件循环的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器和-node-事件循环的区别"}},[e._v("#")]),e._v(" 浏览器和 Node 事件循环的区别")]),e._v(" "),v("p",[v("strong",[e._v("【浏览器】")])]),e._v(" "),v("p",[e._v("关于浏览器的事件循环机制，我总结了一篇较详细的博客："),v("a",{attrs:{href:"https://iloveyou11.github.io/2019/07/01/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-01-JS%E6%B7%B1%E5%85%A5%EF%BC%88%E4%B8%8A%EF%BC%89/",target:"_blank",rel:"noopener noreferrer"}},[e._v("博客地址"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("关于微任务和宏任务在浏览器的执行顺序是这样的：")]),e._v(" "),v("ul",[v("li",[e._v("执行一只task（宏任务）")]),e._v(" "),v("li",[e._v("执行完micro-task队列 （微任务）")]),e._v(" "),v("li",[e._v("如此循环往复下去")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://img.alicdn.com/imgextra/i1/O1CN01H2ACHF26VXJIZTwg2_!!6000000007667-2-tps-1718-1004.png",alt:"浏览器事件循环机制"}})]),e._v(" "),v("ul",[v("li",[e._v("宏任务一般包括：整体代码script，setTimeout，setInterval、setImmediate、I/O 操作、UI 渲染等。")]),e._v(" "),v("li",[e._v("微任务一般包括：new Promise().then(回调)、MutationObserver(html5新特性) 、process.nextTick等。")])]),e._v(" "),v("p",[v("strong",[e._v("【Node】")])]),e._v(" "),v("p",[e._v("Node的事件循环是libuv实现的。")]),e._v(" "),v("blockquote",[v("p",[e._v("libuv库是多平台C库，提供对基于事件循环的异步I/O的支持。它支持epoll、kqueue、Windows的IOCP和Solaris的事件端口。它主要设计用于Node.js，但也可用于其他软件项目如Julia或pyuv等。")])]),e._v(" "),v("p",[e._v("Node事件循环机制如下：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://user-images.githubusercontent.com/20101525/53734427-eba9e880-3ebe-11e9-8511-eb4948e336ae.png",alt:"Node事件循环机制"}})]),e._v(" "),v("p",[e._v("宏任务的执行顺序如下：")]),e._v(" "),v("ul",[v("li",[e._v("timers定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。")]),e._v(" "),v("li",[e._v("pending callbacks待定回调：执行延迟到下一个循环迭代的 I/O 回调。")]),e._v(" "),v("li",[e._v("idle, prepare：仅系统内部使用。")]),e._v(" "),v("li",[e._v("poll 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。")]),e._v(" "),v("li",[e._v("check 检测：setImmediate() 回调函数在这里执行。")]),e._v(" "),v("li",[e._v("close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on('close', ...)。")])]),e._v(" "),v("p",[e._v("微任务和宏任务在Node的执行顺序（Node10之前和Node11以后是不一样的）：")]),e._v(" "),v("p",[e._v("（1）Node10之前")]),e._v(" "),v("ul",[v("li",[e._v("执行完一个阶段的所有任务")]),e._v(" "),v("li",[e._v("执行完nextTick队列里面的内容")]),e._v(" "),v("li",[e._v("然后执行完微任务队列的内容")])]),e._v(" "),v("p",[e._v("（2）Node11以后")]),e._v(" "),v("ul",[v("li",[e._v("和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。")])])])}),[],!1,null,null,null);t.default=l.exports}}]);