(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{425:function(t,e,d){"use strict";d.r(e);var i=d(44),v=Object(i.a)({},(function(){var t=this,e=t.$createElement,d=t._self._c||e;return d("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[d("h3",{attrs:{id:"css获取宽高的方式"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#css获取宽高的方式"}},[t._v("#")]),t._v(" css获取宽高的方式")]),t._v(" "),d("table",[d("thead",[d("tr",[d("th",[t._v("代码")]),t._v(" "),d("th",[t._v("说明")])])]),t._v(" "),d("tbody",[d("tr",[d("td",[t._v("dom.style.width/height")]),t._v(" "),d("td",[t._v("这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。")])]),t._v(" "),d("tr",[d("td",[t._v("dom.currentStyle.width/height")]),t._v(" "),d("td",[t._v("这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持。")])]),t._v(" "),d("tr",[d("td",[t._v("window.getComputedStyle(dom).width/height")]),t._v(" "),d("td",[t._v("这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。")])]),t._v(" "),d("tr",[d("td",[t._v("dom.getBoundingClientRect().width/height")]),t._v(" "),d("td",[t._v("这种方式是根据元素在视窗中的绝对位置来获取宽高的。")])]),t._v(" "),d("tr",[d("td",[t._v("dom.offsetWidth/offsetHeight")]),t._v(" "),d("td",[t._v("最常用的，也是兼容最好的。")])])])]),t._v(" "),d("p",[d("strong",[t._v("扩展")])]),t._v(" "),d("ul",[d("li",[t._v("获取屏幕的高度和宽度（屏幕分辨率）： window.screen.height/width")]),t._v(" "),d("li",[t._v("获取屏幕工作区域的高度和宽度（去掉状态栏）： window.screen.availHeight/availWidth")]),t._v(" "),d("li",[t._v("网页全文的高度和宽度： document.body.scrollHeight/Width")]),t._v(" "),d("li",[t._v("滚动条卷上去的高度和向右卷的宽度： document.body.scrollTop/scrollLeft")]),t._v(" "),d("li",[t._v("网页可见区域的高度和宽度（不加边线）： document.body.clientHeight/clientWidth")]),t._v(" "),d("li",[t._v("网页可见区域的高度和宽度（加边线）： document.body.offsetHeight/offsetWidth")])])])}),[],!1,null,null,null);e.default=v.exports}}]);