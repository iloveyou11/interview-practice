(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{502:function(s,t,n){"use strict";n.r(t);var e=n(44),p=Object(e.a)({},(function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h3",{attrs:{id:"npm模块的安装机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#npm模块的安装机制"}},[s._v("#")]),s._v(" npm模块的安装机制")]),s._v(" "),n("p",[n("strong",[s._v("npm模块的安装步骤：")])]),s._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[n("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 查询node_modules目录之中是否已经存在指定模块\n  "),n("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 若存在，不再重新安装\n  "),n("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 若不存在\n    "),n("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" npm 向 registry 查询模块压缩包的网址\n    "),n("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 下载压缩包，存放在根目录下的.npm目录里\n    "),n("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 解压压缩包到当前项目的node_modules目录\n")])])]),n("p",[n("strong",[s._v("实现过程：")])]),s._v(" "),n("ol",[n("li",[s._v("执行"),n("code",[s._v("preinstall")]),s._v("钩子（如果有定义）")]),s._v(" "),n("li",[s._v("首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块。npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。")]),s._v(" "),n("li",[s._v("获取模块（递归）\n"),n("ul",[n("li",[s._v("获取模块版本信息。在下载一个模块之前，首先要确定其版本。此时如果版本描述文件（如package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 "),n("code",[s._v("packaeg.json")]),s._v(" 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。")]),s._v(" "),n("li",[s._v("获取模块代码。上一步会获取到模块的压缩包地址，npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。")]),s._v(" "),n("li",[s._v("查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。")])])]),s._v(" "),n("li",[s._v("模块扁平化\n"),n("ul",[n("li",[s._v("因为依赖树中可能存在相同的模块依赖（如A模块依赖axios、B模块也依赖axios），按照上面的安装方法就会造成模块冗余。")]),s._v(" "),n("li",[s._v("这时候就需要加入模块扁平化的过程了。遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有重复模块（模块名相同且 semver 兼容，每个 semver 都对应一段版本允许范围）时，则将其丢弃。")])])]),s._v(" "),n("li",[s._v("安装模块\n更新node_modules，依次执行模块中的生命周期函数（按照 "),n("code",[s._v("preinstall、install、postinstall")]),s._v(" 的顺序）。")]),s._v(" "),n("li",[s._v("执行工程的钩子函数\n当前 npm 工程如果定义了钩子此时会被执行（按照 "),n("code",[s._v("install、postinstall、prepublish、prepare")]),s._v(" 的顺序）。")])]),s._v(" "),n("p",[s._v("【扩展】")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("package-lock.json有什么作用？\n锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致。")])]),s._v(" "),n("li",[n("p",[s._v("dependencies中"),n("code",[s._v('"@types/node": "^8.0.33"')]),s._v("的"),n("code",[s._v("^")]),s._v("是什么意思？\n向上标号^是定义了向后（新）兼容依赖，指如果 types/node的版本是超过8.0.33，并在大版本号（8）上相同，就允许下载最新版本的 types/node库包。原来package.json文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次npm install都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以package-lock.json文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。")])]),s._v(" "),n("li",[n("p",[s._v("什么是npm hooks？它有什么作用？")])])]),s._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[s._v("prepublish: 在publish该包之前执行。(在包目录下执行npm install时也会执行)\npostpublish: 在该包publish之后执行\n\npreinstall: 在该包被install之前执行\npostinstall: 在该包被install之后执行\n\npreuninstall: 在该包被uninstall之前执行\npostuninstall: 在该包被uninstall之后执行\n\npreversion: 在修改该包的version之前执行\npostversion: 在修改该包的version之后执行\n\npretest, posttest: 在该包内执行test时执行，其中pretest先于posttest\nprestop, poststop: 在该包内执行stop时执行，其中prestop先于poststop\nprestart,poststart: 在该包内执行start时执行，其中prestart先于poststart\nprerestart, postrestart: 在该包内执行restart脚本时执行，其中prerestart先于postrestart。\n\n注意: 如果没有在scripts里显示指定restart脚本，则会自动调用stop，然后再start\n")])])]),n("p",[s._v("上面这些Hooks都是npm预定义好的，也就是说，当你执行"),n("code",[s._v("npm install")]),s._v("时，如果你在"),n("code",[s._v("scripts")]),s._v("里定义了"),n("code",[s._v("preinstall")]),s._v("和"),n("code",[s._v("postinstall")]),s._v("，那它们分别会在"),n("code",[s._v("npm install")]),s._v("之前/后自动执行。")])])}),[],!1,null,null,null);t.default=p.exports}}]);