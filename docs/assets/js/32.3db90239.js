(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{389:function(t,v,a){"use strict";a.r(v);var e=a(44),n=Object(e.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"如何在h5和小程序中计算白屏时间和首屏时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何在h5和小程序中计算白屏时间和首屏时间"}},[t._v("#")]),t._v(" 如何在H5和小程序中计算白屏时间和首屏时间")]),t._v(" "),a("p",[a("strong",[t._v("（1）白屏时间=页面开始展示的时间点-开始请求时间点")]),t._v("（从空白内容到开始有内容展示）")]),t._v(" "),a("p",[t._v("开始请求时间点可以通过"),a("code",[t._v("Performance Timing.navigation Start")]),t._v("，那么页面开始展示的时间点怎么获取呢？已经知道渲染过程是逐步完成的，而且页面解析是按照文档流从上至下解析的，因此一般认为开始解析body的时间点就是页面开始展示的时间，所以可以通过在head标签的末尾插入script来统计时间节点作为页面开始展示时间节点。但是这种方式需要打点，因此也有很多项目为了简化白屏时间的获取会选择忽略head解析时间直接用"),a("code",[t._v("Performance Timing.dom Loading")]),t._v(" 来表示页面开始展示的时间，即使用"),a("code",[t._v("dom loading-navigation Start")]),t._v("来表示白屏时间。")]),t._v(" "),a("p",[a("strong",[t._v("（2）首屏时间=首屏内容渲染结束时间点-开始请求时间点")]),t._v("（才空白内容到内容展示完全）")]),t._v(" "),a("p",[t._v("同样开始请求时间点可以通过Performance Timing.navigation Start获取。首屏内容渲染结束的时间点通常有以下几种方法获取：")]),t._v(" "),a("p",[t._v("（1）首屏模块标签标记法")]),t._v(" "),a("p",[t._v("适用于于首屏内容不需要通过拉取数据才能生存以及页面不考虑图片等资源加载的情况。通过在 HTML 文档中对应首屏内容的标签结束位置，使用内联的 JavaScript 代码记录当前时间戳作为首屏内容渲染结束的时间点。")]),t._v(" "),a("p",[t._v("（2）统计首屏内加载最慢的图片的时间")]),t._v(" "),a("p",[t._v("通常首屏内容加载最慢的就是图片资源，因此可以把首屏内加载最慢的图片加载完成的时间作为首屏时间。由于浏览器对每个页面的 TCP 连接数有限制，使得并不是所有图片都能立刻开始下载和显示。因此在 DOM树 构建完成后会通过遍历首屏内的所有图片标签，并且监听所有图片标签 onload 事件，最终遍历图片标签的加载时间获取最大值，将这个最大值作为首屏时间。")]),t._v(" "),a("p",[t._v("（3）自定义首屏内容计算法")]),t._v(" "),a("p",[t._v("由于统计首屏内图片完成加载的时间比较复杂。所以在项目中通常会通过自定义模块内容，来简化计算首屏时间。例如忽略图片等资源加载情况，只考虑页面主要 DOM；只考虑首屏的主要模块，而不是严格意义首屏线以上的所有内容。")]),t._v(" "),a("p",[t._v("可交互时间=用户可以正常进行事件输入时间点-开始请求时间点。")]),t._v(" "),a("p",[t._v("PerformanceTiming有一个domInteractive属性，代表了DOM结构结束解析的时间点，就是Document.ready State属性变为“interactive”")])])}),[],!1,null,null,null);v.default=n.exports}}]);